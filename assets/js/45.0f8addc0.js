(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{197:function(t,e,n){"use strict";n.r(e);var i=n(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"设计模式前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设计模式前言","aria-hidden":"true"}},[t._v("#")]),t._v(" 设计模式前言")]),t._v(" "),n("p",[t._v("设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。")]),t._v(" "),n("h2",{attrs:{id:"设计原则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设计原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 设计原则")]),t._v(" "),n("ul",[n("li",[t._v("S – Single Responsibility Principle 单一职责原则")])]),t._v(" "),n("p",[n("strong",[t._v("一个程序只做好一件事,如果功能过于复杂就拆分开，每个部分保持独立")])]),t._v(" "),n("ul",[n("li",[t._v("O – OpenClosed Principle 开放/封闭原则")])]),t._v(" "),n("p",[n("strong",[t._v("对扩展开放，对修改封闭, 增加需求时，扩展新代码，而非修改已有代码")])]),t._v(" "),n("ul",[n("li",[t._v("L – Liskov Substitution Principle 里氏替换原则")])]),t._v(" "),n("p",[n("strong",[t._v("子类能覆盖父类, 父类能出现的地方子类就能出现")])]),t._v(" "),n("ul",[n("li",[t._v("I – Interface Segregation Principle 接口隔离原则")])]),t._v(" "),n("p",[n("strong",[t._v("保持接口的单一独立,类似单一职责原则，这里更关注接口")])]),t._v(" "),n("ul",[n("li",[t._v("D – Dependency Inversion Principle 依赖倒转原则")])]),t._v(" "),n("p",[n("strong",[t._v("面向接口编程，依赖于抽象而不依赖于具体, 使用方只关注接口而不关注具体类的实现")])]),t._v(" "),n("comment")],1)},[],!1,null,null,null);e.default=r.exports}}]);